package discord

import (
	"context"

	"github.com/bwmarrin/discordgo"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceDiscordServerOnboarding() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceServerOnboardingCreate,
		ReadContext:   resourceServerOnboardingRead,
		UpdateContext: resourceServerOnboardingUpdate,
		DeleteContext: resourceServerOnboardingDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Description: "Manages server onboarding configuration. Onboarding allows new members to customize their experience by answering questions that automatically assign roles and grant channel access. Requires at least 1 default channel.",

		Schema: map[string]*schema.Schema{
			"server_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "The ID of the server to configure onboarding for.",
			},
			"enabled": {
				Type:        schema.TypeBool,
				Optional:    true,
				Default:     true,
				Description: "Whether onboarding is enabled. Requires minimum 1 default channel when enabled.",
			},
			"mode": {
				Type:         schema.TypeInt,
				Optional:     true,
				Default:      0,
				ValidateFunc: validation.IntBetween(0, 1),
				Description:  "Onboarding mode. 0 = Default (counts default channels), 1 = Advanced (counts default channels and questions).",
			},
			"default_channel_ids": {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				Description: "Channel IDs that members get opted into automatically. Minimum 1 required.",
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},
			"prompt": {
				Type:        schema.TypeList,
				Optional:    true,
				Description: "Prompts (questions) shown during onboarding and in the Channels & Roles customization tab.",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"id": {
							Type:        schema.TypeString,
							Computed:    true,
							Description: "ID of the prompt. Automatically generated by Discord.",
						},
						"type": {
							Type:         schema.TypeInt,
							Optional:     true,
							Default:      0,
							ValidateFunc: validation.IntBetween(0, 1),
							Description:  "Type of prompt. 0 = Multiple Choice, 1 = Dropdown.",
						},
						"title": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Title of the prompt (question text).",
						},
						"single_select": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     false,
							Description: "Whether users are limited to selecting one option. Default false (allows multiple selections).",
						},
						"required": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     false,
							Description: "Whether the prompt is required before a user completes onboarding.",
						},
						"in_onboarding": {
							Type:        schema.TypeBool,
							Optional:    true,
							Default:     true,
							Description: "Whether the prompt is shown in the onboarding flow. If false, only appears in Channels & Roles tab.",
						},
						"option": {
							Type:        schema.TypeList,
							Required:    true,
							MinItems:    1,
							Description: "Options (answers) available for this prompt.",
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"id": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: "ID of the option. Automatically generated by Discord.",
									},
									"title": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Title of the option.",
									},
									"description": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Description of the option.",
									},
									"channel_ids": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: "Channel IDs a member is added to when selecting this option.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"role_ids": {
										Type:        schema.TypeList,
										Optional:    true,
										Description: "Role IDs assigned to a member when selecting this option.",
										Elem: &schema.Schema{
											Type: schema.TypeString,
										},
									},
									"emoji_id": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Emoji ID for the option (custom emoji).",
									},
									"emoji_name": {
										Type:        schema.TypeString,
										Optional:    true,
										Description: "Emoji name for the option (unicode emoji or custom emoji name).",
									},
									"emoji_animated": {
										Type:        schema.TypeBool,
										Optional:    true,
										Default:     false,
										Description: "Whether the emoji is animated.",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceServerOnboardingCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Context).Session

	serverID := d.Get("server_id").(string)

	// Verify server exists
	if _, err := client.Guild(serverID, discordgo.WithContext(ctx)); err != nil {
		return diag.Errorf("Server does not exist with ID %s: %s", serverID, err.Error())
	}

	// Build onboarding configuration
	onboarding := buildOnboardingFromResourceData(d)
	onboarding.GuildID = serverID

	// Create/update onboarding
	result, err := client.GuildOnboardingEdit(serverID, onboarding, discordgo.WithContext(ctx))
	if err != nil {
		return diag.Errorf("Failed to create onboarding for server %s: %s", serverID, err.Error())
	}

	// Set resource ID to server ID (onboarding is server-scoped)
	d.SetId(serverID)

	// Update state with response data
	return setOnboardingResourceData(ctx, d, result)
}

func resourceServerOnboardingRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Context).Session

	serverID := d.Id()

	onboarding, err := client.GuildOnboarding(serverID, discordgo.WithContext(ctx))
	if err != nil {
		// If server or onboarding doesn't exist, remove from state
		tflog.Warn(ctx, "Failed to fetch onboarding, removing from state", map[string]interface{}{
			"server_id": serverID,
			"error":     err.Error(),
		})
		d.SetId("")
		return nil
	}

	// Update state with current onboarding data
	return setOnboardingResourceData(ctx, d, onboarding)
}

func resourceServerOnboardingUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Context).Session

	serverID := d.Id()

	// Build updated onboarding configuration
	onboarding := buildOnboardingFromResourceData(d)
	onboarding.GuildID = serverID

	// Update onboarding
	result, err := client.GuildOnboardingEdit(serverID, onboarding, discordgo.WithContext(ctx))
	if err != nil {
		return diag.Errorf("Failed to update onboarding for server %s: %s", serverID, err.Error())
	}

	// Update state with response data
	return setOnboardingResourceData(ctx, d, result)
}

func resourceServerOnboardingDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
	client := m.(*Context).Session

	serverID := d.Id()

	// Discord doesn't allow deleting onboarding, so we disable it
	onboarding := &discordgo.GuildOnboarding{
		GuildID:           serverID,
		Enabled:           BoolPtr(false),
		DefaultChannelIDs: []string{},
		Prompts:           &[]discordgo.GuildOnboardingPrompt{},
	}

	if _, err := client.GuildOnboardingEdit(serverID, onboarding, discordgo.WithContext(ctx)); err != nil {
		return diag.Errorf("Failed to disable onboarding for server %s: %s", serverID, err.Error())
	}

	d.SetId("")
	return nil
}

// buildOnboardingFromResourceData constructs a GuildOnboarding object from Terraform resource data
func buildOnboardingFromResourceData(d *schema.ResourceData) *discordgo.GuildOnboarding {
	onboarding := &discordgo.GuildOnboarding{
		Enabled: BoolPtr(d.Get("enabled").(bool)),
	}

	// Set mode
	mode := discordgo.GuildOnboardingMode(d.Get("mode").(int))
	onboarding.Mode = &mode

	// Set default channel IDs
	if v, ok := d.GetOk("default_channel_ids"); ok {
		channelList := v.([]interface{})
		channels := make([]string, len(channelList))
		for i, ch := range channelList {
			channels[i] = ch.(string)
		}
		onboarding.DefaultChannelIDs = channels
	}

	// Build prompts
	if v, ok := d.GetOk("prompt"); ok {
		promptList := v.([]interface{})
		prompts := make([]discordgo.GuildOnboardingPrompt, len(promptList))

		for i, p := range promptList {
			promptMap := p.(map[string]interface{})
			prompt := discordgo.GuildOnboardingPrompt{
				Type:         discordgo.GuildOnboardingPromptType(promptMap["type"].(int)),
				Title:        promptMap["title"].(string),
				SingleSelect: promptMap["single_select"].(bool),
				Required:     promptMap["required"].(bool),
				InOnboarding: promptMap["in_onboarding"].(bool),
			}

			// Set ID if it exists (for updates)
			if id, ok := promptMap["id"].(string); ok && id != "" {
				prompt.ID = id
			} else {
				// For new prompts, use "0" as Discord requires a valid snowflake
				prompt.ID = "0"
			}

			// Build options
			if opts, ok := promptMap["option"].([]interface{}); ok {
				options := make([]discordgo.GuildOnboardingPromptOption, len(opts))

				for j, o := range opts {
					optMap := o.(map[string]interface{})
					option := discordgo.GuildOnboardingPromptOption{
						Title:       optMap["title"].(string),
						Description: optMap["description"].(string),
					}

					// Set ID if it exists (for updates)
					if id, ok := optMap["id"].(string); ok && id != "" {
						option.ID = id
					}

					// Set channel IDs
					if chIDs, ok := optMap["channel_ids"].([]interface{}); ok {
						channelIDs := make([]string, len(chIDs))
						for k, ch := range chIDs {
							channelIDs[k] = ch.(string)
						}
						option.ChannelIDs = channelIDs
					}

					// Set role IDs
					if rIDs, ok := optMap["role_ids"].([]interface{}); ok {
						roleIDs := make([]string, len(rIDs))
						for k, r := range rIDs {
							roleIDs[k] = r.(string)
						}
						option.RoleIDs = roleIDs
					}

					// Set emoji fields directly (used for create/update operations)
					// Note: The API expects emoji_id, emoji_name, emoji_animated as separate fields,
					// not nested in an Emoji object. The Emoji field is only used in responses.
					// Ref for Emoji object: https://github.com/bwmarrin/discordgo/blob/9f6aa8159fc6449dc12c37683bdd995f633c1a42/structs.go#L1198-L1201
					// Ref for create/update as separate fields: https://github.com/bwmarrin/discordgo/blob/9f6aa8159fc6449dc12c37683bdd995f633c1a42/structs.go#L1209-L1217
					if emojiID, hasEmojiID := optMap["emoji_id"].(string); hasEmojiID && emojiID != "" {
						option.EmojiID = emojiID
						// For custom emojis with ID, name can be empty or set
						if emojiName, ok := optMap["emoji_name"].(string); ok {
							option.EmojiName = emojiName
						}
						if emojiAnimated, ok := optMap["emoji_animated"].(bool); ok {
							option.EmojiAnimated = BoolPtr(emojiAnimated)
						}
					} else if emojiName, hasEmojiName := optMap["emoji_name"].(string); hasEmojiName && emojiName != "" {
						// Unicode emoji (no ID, just name)
						option.EmojiName = emojiName
						// Animated should typically be false for unicode emojis
						if emojiAnimated, ok := optMap["emoji_animated"].(bool); ok {
							option.EmojiAnimated = BoolPtr(emojiAnimated)
						}
					}

					options[j] = option
				}

				prompt.Options = options
			}

			prompts[i] = prompt
		}

		onboarding.Prompts = &prompts
	}

	return onboarding
}

// setOnboardingResourceData updates Terraform resource data from a GuildOnboarding object
func setOnboardingResourceData(ctx context.Context, d *schema.ResourceData, onboarding *discordgo.GuildOnboarding) diag.Diagnostics {
	var diags diag.Diagnostics

	d.Set("server_id", onboarding.GuildID)

	if onboarding.Enabled != nil {
		d.Set("enabled", *onboarding.Enabled)
	}

	if onboarding.Mode != nil {
		d.Set("mode", int(*onboarding.Mode))
	}

	if onboarding.DefaultChannelIDs != nil {
		d.Set("default_channel_ids", onboarding.DefaultChannelIDs)
	}

	// Set prompts
	if onboarding.Prompts != nil {
		prompts := make([]interface{}, len(*onboarding.Prompts))

		for i, prompt := range *onboarding.Prompts {
			promptMap := map[string]interface{}{
				"id":            prompt.ID,
				"type":          int(prompt.Type),
				"title":         prompt.Title,
				"single_select": prompt.SingleSelect,
				"required":      prompt.Required,
				"in_onboarding": prompt.InOnboarding,
			}

			// Set options
			options := make([]interface{}, len(prompt.Options))
			for j, opt := range prompt.Options {
				optMap := map[string]interface{}{
					"id":          opt.ID,
					"title":       opt.Title,
					"description": opt.Description,
					"channel_ids": opt.ChannelIDs,
					"role_ids":    opt.RoleIDs,
				}

				// Set emoji fields if present
				if opt.Emoji != nil && (opt.Emoji.ID != "" || opt.Emoji.Name != "") {
					optMap["emoji_id"] = opt.Emoji.ID
					optMap["emoji_name"] = opt.Emoji.Name
					optMap["emoji_animated"] = opt.Emoji.Animated
				} else {
					optMap["emoji_id"] = ""
					optMap["emoji_name"] = ""
					optMap["emoji_animated"] = false
				}

				options[j] = optMap
			}

			promptMap["option"] = options
			prompts[i] = promptMap
		}

		if err := d.Set("prompt", prompts); err != nil {
			return diag.Errorf("Failed to set prompts: %s", err.Error())
		}
	}

	return diags
}
